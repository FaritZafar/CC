## Phase 3  
Write YACC code that uses code from phase 1 and translates a program written in programming language we selected in phase 1 to python code.  

### About YACC  
YACC (yet another compiler-compiler) is an LALR(1) (LookAhead, Left-to-right, Rightmost derivation producer with 1 lookahead token) parser generator. YACC was originally designed for being complemented by Lex.  
Some important points to highlight about YACC are listed below:  
Input: A CFG- file.y  
Output: A parser y.tab.c (yacc)  
* The output file "file.output" contains the parsing tables.  
* The file "file.tab.h" contains declarations.  
* The parser called the yyparse ().
* Parser expects to use a function called yylex () to get tokens.  

### Aproach Used:  
Making a Lexical Analyzer was generally more easy than the Parser at the same time, after reading a lot of documentations and cooperative work, we figured out how to make it happen accurately.  

### Working:  
After download, compile the documents to make an executable, run the executable to parse the source code. There are two methods for giving source code to the executable, we have two methods to set input strings to the executable, first from the standard input in the cl(command line), second from a text file.
The executable would parse the source program and let user know, whether there are any parsing errors in the program.  

### YACC and Flex Compilation  
* lex lexer.l  
* yacc -d parser.y -v  
* gcc -w -g y.tab.c -ly -ll -o semantic_analyser  
![image](https://user-images.githubusercontent.com/77563804/184531900-9a1e3239-e559-43b7-9296-f275fda7fa77.png)  

### Files used in our Phase 3  
[YACC Code.txt](https://github.com/FaritZafar/CC/files/9338345/YACC.Code.txt)  
[Flex Files.txt](https://github.com/FaritZafar/CC/files/9338346/Flex.Files.txt)  
[Mini C Code Input File.txt](https://github.com/FaritZafar/CC/files/9338347/Mini.C.Code.Input.File.txt)  
[Python Code Output File.txt](https://github.com/FaritZafar/CC/files/9338348/Python.Code.Output.File.txt)  

### About the files  


### (Gcc) Compilation:  
Compile the file of c that has been generated by yacc,t  and that will create the main executable name i-e x.exe on windows and x.out on linux, or we can provide -o flag to oveeride the executable default filename.  

![image](https://user-images.githubusercontent.com/77563804/184531948-8fe169a8-37b2-44e9-9c0f-b5a43b817586.png)

### ScreenShots
Screenshot 1:  
![YACC Cmd](https://user-images.githubusercontent.com/83082151/184548478-a5a81f31-5622-4ce3-ac5a-2fd68299d4c5.PNG)  

Screenshot 2:  
![YACC Input](https://user-images.githubusercontent.com/83082151/184548505-b89646bc-e563-47ec-a418-b5b008aeaf07.PNG)  

Screenshot 3:   
![YACC Output](https://user-images.githubusercontent.com/83082151/184548519-fe62684e-63ce-4343-ad17-628c704b8c07.PNG)  

### Video  
https://user-images.githubusercontent.com/83082151/184548538-c25365cc-c467-4ebe-9a0b-418de64b586b.mp4  

### The problems we face:  
### In Language grammar interpreting:  
It took a long time to understand the Mini-C language grammar,but as soon as we study things from our course and internet the things start making sense and become understandable.  
### In the scanner with parser integration:
It was very difficult to find flex and yacc programs integration so we found an easy example on our website of course and we took help from it.  
### Elimination of the grammar conflicts in parser:
At the initial implementation of parser we faced huge number of conflicts in grammar because there are many places where we have clear grammar without (fuzzy rules) but the yacc cannot handle it because it generates LALR(1) parsers by default with limited look ahead ability.  
By specifying the associativity property of different operators, we resolve many shift/reduce issues in the yacc program, and by opening and closing curly braces {} the remaining conflicts were eliminated and also we resolve some statements by using various precedence rules to associate else with the nearest if.  
